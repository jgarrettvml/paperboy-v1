<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paperboy 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: yellow;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 200;
            color: white;
        }
        #start-screen h1 {
            font-size: 48px;
            color: yellow;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #ff0000;
        }
        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 20px;
        }
        #start-button:hover {
            background-color: #cc0000;
        }
        #game-over {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 300;
            color: white;
        }
        #game-over h2 {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 20px;
        }
        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 20px;
        }
        #restart-button:hover {
            background-color: #cc0000;
        }
        @font-face {
            font-family: 'Press Start 2P';
            src: url('https://fonts.gstatic.com/s/pressstart2p/v14/e3t4euO8T-267oIAQAu6jDQyK0nS.woff2') format('woff2');
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-container">
            <div>SCORE: <span id="score">0</span></div>
            <div>PAPERS: <span id="papers">20</span></div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
        <div id="instructions">
            <p>Arrow keys or WASD to move</p>
            <p>Space bar to throw paper</p>
            <p>Deliver to mailboxes (20 pts) or porches (10 pts)</p>
            <p>Avoid obstacles (-5 pts)</p>
            <p>Jump hills in parks for bonus points (+20 pts)</p>
        </div>
        <div id="start-screen">
            <h1>PAPERBOY 3D</h1>
            <p>Deliver newspapers to houses and avoid obstacles!</p>
            <button id="start-button">START GAME</button>
        </div>
        <div id="game-over">
            <h2>GAME OVER</h2>
            <div>FINAL SCORE: <span id="final-score">0</span></div>
            <button id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // Game variables
        let scene, camera, renderer;
        let player, playerObject, playerSpeed = 0.15;
        let gameActive = false;
        let score = 0;
        let papers = 20;
        let lives = 3;
        let gameBlocks = [];
        let obstacles = [];
        let houses = [];
        let newspapers = [];
        let mailboxes = [];
        let porches = [];
        let blockLength = 30;
        let blockWidth = 20;
        let streetWidth = 10;
        let currentBlock = 0;
        let totalBlocks = 20;
        let jumpHeight = 0;
        let isJumping = false;
        let jumpSpeed = 0.2;
        let playerHeight = 1;
        let clock = new THREE.Clock();
        let deltaTime;
        let playerInvincible = false;
        let playerInvincibleTime = 0;
        let playerBlinkTime = 0;
        let playerVisible = true;
        let gameTime = 0;

        // DOM elements
        const scoreElement = document.getElementById('score');
        const papersElement = document.getElementById('papers');
        const livesElement = document.getElementById('lives');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // Colors for the game
        const COLORS = {
            STREET: 0x888888,
            SIDEWALK: 0xcccccc,
            GRASS: 0x33cc33,
            HOUSE_WALL: 0x666666,
            HOUSE_ROOF: 0x333333,
            PORCH: 0xffffff,
            MAILBOX: 0xff0000,
            CAR: 0xff0000,
            PLAYER: 0x0000ff,
            NEWSPAPER: 0xffff00,
            HILL: 0x228822,
            DRAIN: 0x444444
        };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, -15);
            camera.lookAt(0, 0, 10);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            scene.add(directionalLight);

            // Create player
            createPlayer();

            // Generate the game world
            generateWorld();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Set up controls
            setupControls();

            // Start the game loop
            animate();
        }

        // Create the player character
        function createPlayer() {
            playerObject = new THREE.Group();
            
            // Create bicycle
            const bikeFrame = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            bikeFrame.position.y = 0.5;
            playerObject.add(bikeFrame);

            // Wheels
            const wheelGeometry = new THREE.TorusGeometry(0.5, 0.1, 16, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontWheel.position.set(0, 0.5, -0.6);
            frontWheel.rotation.x = Math.PI / 2;
            playerObject.add(frontWheel);
            
            const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backWheel.position.set(0, 0.5, 0.6);
            backWheel.rotation.x = Math.PI / 2;
            playerObject.add(backWheel);

            // Rider
            const riderBody = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.8, 0.4),
                new THREE.MeshLambertMaterial({ color: COLORS.PLAYER })
            );
            riderBody.position.set(0, 1.2, 0);
            playerObject.add(riderBody);

            const riderHead = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xFFCCAA })
            );
            riderHead.position.set(0, 1.7, 0);
            playerObject.add(riderHead);

            // Newspaper bag
            const newspaperBag = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.4, 0.6),
                new THREE.MeshLambertMaterial({ color: 0xBB5500 })
            );
            newspaperBag.position.set(0, 1.2, 0.5);
            playerObject.add(newspaperBag);

            // Add player to scene
            playerObject.position.set(0, playerHeight, 0);
            playerObject.castShadow = true;
            playerObject.receiveShadow = true;
            scene.add(playerObject);

            // Set player
            player = {
                object: playerObject,
                width: 1,
                height: 2,
                depth: 1.5,
                position: new THREE.Vector3(0, playerHeight, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                speed: playerSpeed,
                canJump: true
            };
        }

        // Generate the game world
        function generateWorld() {
            // Create ground
            for (let i = 0; i < totalBlocks; i++) {
                const isPark = i > 0 && i % 3 === 0;
                createBlock(i, isPark);
            }
        }

        // Create a block of houses or a park
        function createBlock(blockIndex, isPark) {
            const blockZ = blockIndex * (blockLength + streetWidth);
            const block = new THREE.Group();
            block.position.z = blockZ;
            
            if (isPark) {
                createPark(block);
            } else {
                createHousesBlock(block);
            }
            
            // Add cross-street at the end of each block
            if (blockIndex > 0) {
                createCrossStreet(block, -streetWidth/2);
            }
            
            scene.add(block);
            gameBlocks.push(block);
        }
        
        // Create a cross-street
        function createCrossStreet(blockGroup, zOffset) {
            // Street
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth * 3, streetWidth),
                new THREE.MeshLambertMaterial({ color: COLORS.STREET })
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0.06, zOffset);
            street.receiveShadow = true;
            blockGroup.add(street);
            
            // White lines on the street
            const lineWidth = 0.3;
            const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            
            // Center line
            const centerLine = new THREE.Mesh(
                new THREE.PlaneGeometry(lineWidth, streetWidth - 1),
                lineMaterial
            );
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.set(0, 0.07, zOffset);
            centerLine.receiveShadow = true;
            blockGroup.add(centerLine);
            
            // Side lines
            for (let i = -1; i <= 1; i += 2) {
                const sideLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(lineWidth, streetWidth - 1),
                    lineMaterial
                );
                sideLine.rotation.x = -Math.PI / 2;
                sideLine.position.set(blockWidth * 0.5 * i, 0.07, zOffset);
                sideLine.receiveShadow = true;
                blockGroup.add(sideLine);
            }
            
            // Add some street props
            addStreetProps(blockGroup, zOffset);
        }
        
        // Add props to the cross-street
        function addStreetProps(blockGroup, zOffset) {
            // Street lights
            for (let i = -1; i <= 1; i += 2) {
                const lightPole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 4, 8),
                    new THREE.MeshLambertMaterial({ color: 0x333333 })
                );
                lightPole.position.set(blockWidth * 0.7 * i, 2, zOffset);
                lightPole.castShadow = true;
                blockGroup.add(lightPole);
                
                const lightHead = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.3, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0x555555 })
                );
                lightHead.position.set(blockWidth * 0.7 * i, 4, zOffset);
                lightHead.castShadow = true;
                blockGroup.add(lightHead);
                
                // Light cone
                const light = new THREE.PointLight(0xFFFF99, 0.5, 10);
                light.position.set(blockWidth * 0.7 * i, 4, zOffset);
                blockGroup.add(light);
            }
            
            // Add stop signs at intersections
            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    if (Math.random() > 0.5) {
                        createStopSign(
                            blockGroup,
                            blockWidth * 0.5 * i,
                            zOffset + streetWidth * 0.4 * j
                        );
                    }
                }
            }
        }
        
        // Create a stop sign
        function createStopSign(blockGroup, x, z) {
            const signGroup = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                new THREE.MeshLambertMaterial({ color: 0x888888 })
            );
            pole.position.y = 1;
            pole.castShadow = true;
            signGroup.add(pole);
            
            // Sign
            const sign = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 0.05, 8),
                new THREE.MeshLambertMaterial({ color: 0xFF0000 })
            );
            sign.position.y = 2;
            sign.rotation.x = Math.PI / 2;
            sign.castShadow = true;
            signGroup.add(sign);
            
            // Add to block
            signGroup.position.set(x, 0, z);
            blockGroup.add(signGroup);
            
            // Register for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 0.3,
                height: 2,
                depth: 0.3,
                type: 'sign'
            });
        }

        function createHouse(blockGroup, x, z, width, length, mailboxOnLeft) {
            const houseGroup = new THREE.Group();
            
            // Set the house back from the street by adding an offset
            const setback = 4; // 4 units back from original position
            
            // Create driveway
            const driveway = new THREE.Mesh(
                new THREE.PlaneGeometry(3, setback),
                new THREE.MeshLambertMaterial({ color: 0x999999 }) // Concrete color
            );
            driveway.rotation.x = -Math.PI / 2;
            driveway.position.set(0, 0.01, -length/2 - setback/2);
            driveway.receiveShadow = true;
            houseGroup.add(driveway);

            // House base - moved back by setback
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(width, 2, length),
                new THREE.MeshLambertMaterial({ color: COLORS.HOUSE_WALL })
            );
            base.position.set(0, 1, -setback);
            base.castShadow = true;
            houseGroup.add(base);
            
            // Roof - moved back by setback
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(width * 0.7, 1.5, 4),
                new THREE.MeshLambertMaterial({ color: COLORS.HOUSE_ROOF })
            );
            roof.position.set(0, 2.75, -setback);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);
            
            // Porch - at the front of the house
            const porch = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.2, 2),
                new THREE.MeshLambertMaterial({ color: COLORS.PORCH })
            );
            porch.userData.type = 'porch';
            
            porch.position.set(0, 0.1, -setback + length/2 + 1);
            porch.receiveShadow = true;
            houseGroup.add(porch);

            // Porch steps
            const steps = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.4, 0.8),
                new THREE.MeshLambertMaterial({ color: COLORS.PORCH })
            );
            steps.position.set(0, 0.2, -setback + length/2 + 2);
            steps.receiveShadow = true;
            houseGroup.add(steps);
            
            // Add mailbox
            const mailboxX = mailboxOnLeft ? -width/2 - 1 : width/2 + 1;
            createMailbox(blockGroup, x + mailboxX, z);
            
            // Add house to block
            houseGroup.position.set(x, 0, z);
            blockGroup.add(houseGroup);
            
            // Add porch to deliverable locations with adjusted position for setback
            porches.push({
                position: new THREE.Vector3(
                    x, 
                    0.2, // Slight elevation for better collision detection
                    z - setback + length/2 + 1 + blockGroup.position.z
                ),
                width: 3,
                height: 0.4, // Add height for better collision detection
                length: 2
            });
        }

        // Create a block with houses
        function createHousesBlock(blockGroup) {
            // Create street
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth + streetWidth * 2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.STREET })
            );
            street.rotation.x = -Math.PI / 2;
            street.position.z = blockLength / 2;
            street.receiveShadow = true;
            blockGroup.add(street);
            
            // Create sidewalks
            const leftSidewalk = new THREE.Mesh(
                new THREE.PlaneGeometry(2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.SIDEWALK })
            );
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-(blockWidth / 2) - 1, 0.05, blockLength / 2);
            leftSidewalk.receiveShadow = true;
            blockGroup.add(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(
                new THREE.PlaneGeometry(2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.SIDEWALK })
            );
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set((blockWidth / 2) + 1, 0.05, blockLength / 2);
            rightSidewalk.receiveShadow = true;
            blockGroup.add(rightSidewalk);
            
            // Create lawns
            const leftLawn = new THREE.Mesh(
                new THREE.PlaneGeometry(8, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.GRASS })
            );
            leftLawn.rotation.x = -Math.PI / 2;
            leftLawn.position.set(-(blockWidth / 2) - 6, 0.05, blockLength / 2);
            leftLawn.receiveShadow = true;
            blockGroup.add(leftLawn);
            
            const rightLawn = new THREE.Mesh(
                new THREE.PlaneGeometry(8, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.GRASS })
            );
            rightLawn.rotation.x = -Math.PI / 2;
            rightLawn.position.set((blockWidth / 2) + 6, 0.05, blockLength / 2);
            rightLawn.receiveShadow = true;
            blockGroup.add(rightLawn);
            
            // Create houses (4 on each side)
            const houseWidth = 6;
            const houseLength = 5;
            const houseSpacing = (blockLength - (houseLength * 4)) / 5;
            
            for (let i = 0; i < 4; i++) {
                const houseZ = houseSpacing + i * (houseLength + houseSpacing);
                
                // Left side house
                createHouse(
                    blockGroup, 
                    -(blockWidth / 2) - 6 + (houseWidth / 2), 
                    houseZ,
                    houseWidth,
                    houseLength,
                    Math.random() > 0.5 // Random side for mailbox
                );
                
                // Right side house
                createHouse(
                    blockGroup, 
                    (blockWidth / 2) + 6 - (houseWidth / 2), 
                    houseZ,
                    houseWidth,
                    houseLength,
                    Math.random() > 0.5 // Random side for mailbox
                );
            }
            
            // Add obstacles
            addObstacles(blockGroup);
        }

        // Create a mailbox with more detail
        function createMailbox(blockGroup, x, z) {
            const mailboxGroup = new THREE.Group();
            mailboxGroup.userData.type = 'mailbox';
            
            // Random mailbox style (0, 1, or 2)
            const mailboxStyle = Math.floor(Math.random() * 3);
            let mailboxColor;
            
            switch(mailboxStyle) {
                case 0: // Classic red
                    mailboxColor = 0xCC0000;
                    break;
                case 1: // Black
                    mailboxColor = 0x222222;
                    break;
                case 2: // Blue
                    mailboxColor = 0x0033AA;
                    break;
            }
            
            // Post
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            
            if (mailboxStyle === 0) { // Wooden post
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1.2, 0.2),
                    postMaterial
                );
                post.position.y = 0.6;
                post.castShadow = true;
                mailboxGroup.add(post);
            } else if (mailboxStyle === 1) { // Metal pole
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                post.position.y = 0.6;
                post.castShadow = true;
                mailboxGroup.add(post);
                
                // Base
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.1, 8),
                    new THREE.MeshLambertMaterial({ color: 0x666666 })
                );
                base.position.y = 0.05;
                base.castShadow = true;
                mailboxGroup.add(base);
            } else { // Stone base
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.9, 0.3),
                    new THREE.MeshLambertMaterial({ color: 0x999999 })
                );
                post.position.y = 0.45;
                post.castShadow = true;
                mailboxGroup.add(post);
                
                // Stone texture
                for (let i = 0; i < 5; i++) {
                    const stone = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05 + Math.random() * 0.1, 0.05 + Math.random() * 0.1, 0.05),
                        new THREE.MeshLambertMaterial({ color: 0x888888 })
                    );
                    stone.position.set(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.8,
                        0.17
                    );
                    post.add(stone);
                }
            }
            
            // Box style based on mailbox type
            let boxGeometry;
            if (mailboxStyle === 0) { // Classic curved top
                boxGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.4);
                
                // Curved top
                const topCurve = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 0.8, 16, 1, false, 0, Math.PI),
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                topCurve.rotation.z = Math.PI / 2;
                topCurve.position.set(0, 0.25, 0);
                
                const box = new THREE.Mesh(
                    boxGeometry,
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                
                const boxWrapper = new THREE.Group();
                boxWrapper.add(box);
                boxWrapper.add(topCurve);
                boxWrapper.position.y = 1.2;
                boxWrapper.castShadow = true;
                mailboxGroup.add(boxWrapper);
                
                // Flag
                const flag = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.3, 0.2),
                    new THREE.MeshLambertMaterial({ color: 0xFF0000 })
                );
                flag.position.set(0.425, 1.3, 0);
                flag.castShadow = true;
                mailboxGroup.add(flag);
                
            } else if (mailboxStyle === 1) { // Modern box with slot
                boxGeometry = new THREE.BoxGeometry(0.8, 0.7, 0.4);
                
                const box = new THREE.Mesh(
                    boxGeometry,
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                box.position.y = 1.2;
                box.castShadow = true;
                mailboxGroup.add(box);
                
                // Mail slot
                const slot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.08, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0x000000 })
                );
                slot.position.set(0, 1.3, 0.225);
                mailboxGroup.add(slot);
                
            } else { // Decorative box
                boxGeometry = new THREE.BoxGeometry(0.9, 0.6, 0.5);
                
                const box = new THREE.Mesh(
                    boxGeometry,
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                box.position.y = 1.1;
                box.castShadow = true;
                mailboxGroup.add(box);
                
                // Decorative trim
                const trim = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.05, 0.6),
                    new THREE.MeshLambertMaterial({ color: 0xDDDDDD })
                );
                trim.position.y = 1.4;
                mailboxGroup.add(trim);
                
                // House number
                const numberPlate = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.15),
                    new THREE.MeshLambertMaterial({ color: 0xEEEEEE })
                );
                numberPlate.position.set(0, 1.25, 0.26);
                mailboxGroup.add(numberPlate);
            }
            
            // Add to block
            mailboxGroup.position.set(x, 0, z);
            blockGroup.add(mailboxGroup);
            
            // Register for collision
            mailboxes.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 1,
                length: 0.5
            });
        }

        // Create a park with more detailed elements
        function createPark(blockGroup) {
            // Create ground with texture variation
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth + streetWidth * 2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.GRASS })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = blockLength / 2;
            ground.receiveShadow = true;
            blockGroup.add(ground);
            
            // Add texture variation with patches of different grass
            for (let i = 0; i < 20; i++) {
                const patchSize = 1.5 + Math.random() * 3;
                const patchX = (Math.random() - 0.5) * (blockWidth + streetWidth * 2 - patchSize);
                const patchZ = Math.random() * blockLength;
                
                const grassPatch = new THREE.Mesh(
                    new THREE.CircleGeometry(patchSize / 2, 8),
                    new THREE.MeshLambertMaterial({ 
                        color: Math.random() > 0.5 ? 0x44AA44 : 0x55BB55,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                grassPatch.rotation.x = -Math.PI / 2;
                grassPatch.position.set(patchX, 0.01, patchZ);
                blockGroup.add(grassPatch);
            }
            
            // Create street/path through the park
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth, blockLength),
                new THREE.MeshLambertMaterial({ color: 0xbbbbbb }) // Lighter color for park path
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0.05, blockLength / 2);
            street.receiveShadow = true;
            blockGroup.add(street);
            
            // Add path texture - crossing lines
            for (let i = 0; i < blockLength / 2; i++) {
                const pathLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(blockWidth, 0.1),
                    new THREE.MeshLambertMaterial({ color: 0x999999 })
                );
                pathLine.rotation.x = -Math.PI / 2;
                pathLine.position.set(0, 0.06, i * 2);
                blockGroup.add(pathLine);
            }
            
            // Create hills - more varied
            for (let i = 0; i < 3; i++) {
                const hillZ = blockLength / 4 + i * (blockLength / 3);
                const offsetX = (i % 2 === 0) ? 2 : -2; // Alternate sides
                createHill(blockGroup, offsetX, hillZ);
            }
            
            // Add some trees - more variety
            for (let i = 0; i < 12; i++) {
                const treeX = (Math.random() - 0.5) * (blockWidth + streetWidth * 2 - 4);
                const treeZ = Math.random() * blockLength;
                
                // Don't place trees on the path
                if (Math.abs(treeX) > 5) {
                    createTree(blockGroup, treeX, treeZ, Math.floor(Math.random() * 3));
                }
            }
            
            // Add park benches
            for (let i = 0; i < 3; i++) {
                const benchSide = i % 2 === 0 ? 1 : -1;
                const benchX = benchSide * (blockWidth / 2 - 2);
                const benchZ = blockLength / 4 + i * (blockLength / 3);
                createBench(blockGroup, benchX, benchZ, benchSide);
            }
            
            // Add some flowers
            for (let i = 0; i < 20; i++) {
                const flowerX = (Math.random() - 0.5) * (blockWidth + streetWidth * 2 - 2);
                const flowerZ = Math.random() * blockLength;
                
                // Don't place flowers on the path
                if (Math.abs(flowerX) > 5) {
                    createFlower(blockGroup, flowerX, flowerZ);
                }
            }
            
            // Add a small pond
            if (Math.random() > 0.5) {
                const pondX = (Math.random() - 0.5) * (blockWidth - 10);
                const pondZ = blockLength / 2 + (Math.random() - 0.5) * (blockLength / 2 - 5);
                createPond(blockGroup, pondX, pondZ);
            }
        }
        
        // Create improved hill
        function createHill(blockGroup, x, z) {
            const hillWidth = 10;
            const hillHeight = 2;
            
            // Random hill size variation
            const sizeVariation = 0.7 + Math.random() * 0.6;
            const actualWidth = hillWidth * sizeVariation;
            const actualHeight = hillHeight * sizeVariation;
            
            // Create hill geometry
            const hillGeometry = new THREE.CylinderGeometry(
                0, 
                actualWidth / 2, 
                actualHeight, 
                16, 
                1, 
                false
            );
            hillGeometry.rotateX(Math.PI / 2);
            
            // Hill color variation
            const hillColor = Math.random() > 0.5 ? 0x228822 : 0x2A9D2A;
            
            const hill = new THREE.Mesh(
                hillGeometry,
                new THREE.MeshLambertMaterial({ color: hillColor })
            );
            hill.position.set(x, actualHeight / 2, z);
            hill.castShadow = true;
            hill.receiveShadow = true;
            blockGroup.add(hill);
            
            // Add some details to the hill
            // Small rocks
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * (actualWidth / 2);
                const rockX = x + Math.cos(angle) * distance;
                const rockZ = z + Math.sin(angle) * distance;
                const rockHeight = Math.random() * actualHeight;
                
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.2 + Math.random() * 0.3, 0),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                rock.position.set(rockX, rockHeight * 0.7, rockZ);
                blockGroup.add(rock);
            }
            
            // Register hill for collision and jumping
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: actualWidth,
                height: actualHeight,
                depth: actualWidth,
                type: 'hill'
            });
        }
        
        // Create improved tree with different styles
        function createTree(blockGroup, x, z, style = 0) {
            const treeGroup = new THREE.Group();
            
            // Different tree styles
            if (style === 0) { // Pine tree
                // Trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.3, 2, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Leaves - multiple layers of cones
                for (let i = 0; i < 3; i++) {
                    const coneSize = 1.5 - i * 0.3;
                    const coneHeight = 1.5 - i * 0.2;
                    const coneY = 2 + i * 0.8;
                    
                    const leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(coneSize, coneHeight, 8),
                        new THREE.MeshLambertMaterial({ color: 0x228822 })
                    );
                    leaves.position.y = coneY;
                    leaves.castShadow = true;
                    treeGroup.add(leaves);
                }
            } else if (style === 1) { // Oak tree
                // Thicker trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: 0x6B4423 })
                );
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Spherical foliage
                const leaves = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0x4D8C57 })
                );
                leaves.position.y = 3.5;
                leaves.castShadow = true;
                treeGroup.add(leaves);
                
                // Add some branch details
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const branch = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.2, 1.5, 4),
                        new THREE.MeshLambertMaterial({ color: 0x6B4423 })
                    );
                    branch.position.set(
                        Math.cos(angle) * 0.7,
                        2,
                        Math.sin(angle) * 0.7
                    );
                    branch.rotation.z = Math.PI / 3;
                    branch.rotation.y = angle;
                    treeGroup.add(branch);
                }
            } else { // Maple tree
                // Thin trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.35, 3, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                trunk.position.y = 1.5;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Colorful foliage - multiple spheres
                const colors = [0xE27D60, 0xE8A87C, 0xC38D9E, 0xE8D2AE]; // Fall colors
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = 0.7 + Math.random() * 0.5;
                    
                    const leafCluster = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8 + Math.random() * 0.4, 8, 8),
                        new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random() * colors.length)] })
                    );
                    leafCluster.position.set(
                        Math.cos(angle) * distance,
                        3 + Math.random() * 0.5,
                        Math.sin(angle) * distance
                    );
                    leafCluster.castShadow = true;
                    treeGroup.add(leafCluster);
                }
            }
            
            // Add to block
            treeGroup.position.set(x, 0, z);
            blockGroup.add(treeGroup);
            
            // Register for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 1,
                height: style === 1 ? 4.5 : 4,
                depth: 1,
                type: 'tree'
            });
        }
        
        // Create a park bench
        function createBench(blockGroup, x, z, facing = 1) {
            const benchGroup = new THREE.Group();
            
            // Bench seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.1, 0.7),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            seat.position.y = 0.5;
            benchGroup.add(seat);
            
            // Bench back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.7, 0.1),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            back.position.set(0, 0.8, -0.3 * facing);
            benchGroup.add(back);
            
            // Bench legs
            for (let i = -1; i <= 1; i += 2) {
                const leg = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.5, 0.7),
                    new THREE.MeshLambertMaterial({ color: 0x666666 })
                );
                leg.position.set(i * 0.9, 0.25, 0);
                benchGroup.add(leg);
                
                // Back support
                const backSupport = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.7, 0.1),
                    new THREE.MeshLambertMaterial({ color: 0x666666 })
                );
                backSupport.position.set(i * 0.9, 0.8, -0.3 * facing);
                benchGroup.add(backSupport);
            }
            
            // Add to block
            benchGroup.position.set(x, 0, z);
            benchGroup.rotation.y = facing > 0 ? Math.PI : 0;
            blockGroup.add(benchGroup);
            
            // Register for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 2,
                height: 1,
                depth: 0.7,
                type: 'bench'
            });
        }
        
        // Create flowers
        function createFlower(blockGroup, x, z) {
            const flowerGroup = new THREE.Group();
            
            // Stem
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8),
                new THREE.MeshLambertMaterial({ color: 0x228822 })
            );
            stem.position.y = 0.15;
            flowerGroup.add(stem);
            
            // Flower head - random color
            const colors = [0xFF5555, 0xFFFF55, 0xFF55FF, 0x55FFFF, 0xFFAA55, 0xAA55FF];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const flowerType = Math.floor(Math.random() * 2);
            
            if (flowerType === 0) { // Daisy-like flower
                // Petals
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const petal = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.1, 0.1),
                        new THREE.MeshLambertMaterial({ 
                            color: color,
                            side: THREE.DoubleSide
                        })
                    );
                    petal.position.set(
                        Math.cos(angle) * 0.08,
                        0.3,
                        Math.sin(angle) * 0.08
                    );
                    petal.rotation.x = Math.PI / 2;
                    petal.rotation.y = angle;
                    flowerGroup.add(petal);
                }
                
                // Center
                const center = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0xFFFF00 })
                );
                center.position.y = 0.3;
                flowerGroup.add(center);
            } else { // Tulip-like flower
                const flower = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.15, 6, 1, true),
                    new THREE.MeshLambertMaterial({ color: color })
                );
                flower.position.y = 0.35;
                flower.rotation.x = Math.PI;
                flowerGroup.add(flower);
            }
            
            // Add to block
            flowerGroup.position.set(x, 0, z);
            blockGroup.add(flowerGroup);
        }
        
        // Create a small pond
        function createPond(blockGroup, x, z) {
            // Pond base - slightly depressed into ground
            const pondSize = 3 + Math.random() * 2;
            const pondDepth = 0.3;
            
            // Dig out pond area
            const pondHole = new THREE.Mesh(
                new THREE.CylinderGeometry(pondSize/2, pondSize/2, pondDepth, 24),
                new THREE.MeshLambertMaterial({ color: 0x667788 })
            );
            pondHole.position.set(x, -pondDepth/2 + 0.01, z);
            pondHole.rotation.x = Math.PI / 2;
            blockGroup.add(pondHole);
            
            // Water surface
            const waterSurface = new THREE.Mesh(
                new THREE.CircleGeometry(pondSize/2 - 0.1, 24),
                new THREE.MeshLambertMaterial({ 
                    color: 0x3399CC,
                    transparent: true,
                    opacity: 0.7
                })
            );
            waterSurface.position.set(x, 0.03, z);
            waterSurface.rotation.x = -Math.PI / 2;
            blockGroup.add(waterSurface);
            
            // Add rocks around the edge
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const distance = pondSize/2 - 0.2 + Math.random() * 0.4;
                
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.15 + Math.random() * 0.15, 0),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                rock.position.set(
                    x + Math.cos(angle) * distance,
                    0.1,
                    z + Math.sin(angle) * distance
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                blockGroup.add(rock);
            }
            
            // Register pond for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: pondSize,
                height: 0.1,
                depth: pondSize,
                type: 'pond'
            });
        }

        // Add obstacles to a block
        function addObstacles(blockGroup) {
            // Add cars
            for (let i = 0; i < 2; i++) {
                const carX = (Math.random() - 0.5) * (blockWidth - 4);
                const carZ = Math.random() * blockLength;
                createCar(blockGroup, carX, carZ);
            }
            
            // Add street drains
            for (let i = 0; i < 3; i++) {
                const drainX = (Math.random() - 0.5) * blockWidth;
                const drainZ = i * (blockLength / 3) + Math.random() * (blockLength / 6);
                createDrain(blockGroup, drainX, drainZ);
            }
        }

        // Create a car
        function createCar(blockGroup, x, z) {
            const carGroup = new THREE.Group();
            
            // Car body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 4),
                new THREE.MeshLambertMaterial({ color: COLORS.CAR })
            );
            body.position.y = 0.75;
            body.castShadow = true;
            carGroup.add(body);
            
            // Car top
            const top = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.8, 2),
                new THREE.MeshLambertMaterial({ color: COLORS.CAR })
            );
            top.position.set(0, 1.7, -0.5);
            top.castShadow = true;
            carGroup.add(top);
            
            // Windows
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x88CCFF });
            
            // Windshield
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(1.7, 0.7),
                windowMaterial
            );
            windshield.position.set(0, 1.7, 0.51);
            windshield.rotation.x = Math.PI / 2;
            carGroup.add(windshield);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            
            const wheelFL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFL.position.set(-1.1, 0.4, -1.5);
            carGroup.add(wheelFL);
            
            const wheelFR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFR.position.set(1.1, 0.4, -1.5);
            carGroup.add(wheelFR);
            
            const wheelBL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelBL.position.set(-1.1, 0.4, 1.5);
            carGroup.add(wheelBL);
            
            const wheelBR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelBR.position.set(1.1, 0.4, 1.5);
            carGroup.add(wheelBR);
            
            // Add to block
            carGroup.position.set(x, 0, z);
            carGroup.rotation.y = Math.random() * Math.PI * 2; // Random rotation
            blockGroup.add(carGroup);
            
            // Register for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 2,
                height: 1.7,
                depth: 4,
                type: 'car'
            });
        }

        // Create a drain
        function createDrain(blockGroup, x, z) {
            const drain = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.1, 1),
                new THREE.MeshLambertMaterial({ color: COLORS.DRAIN })
            );
            drain.position.set(x, 0.05, z);
            drain.rotation.x = -Math.PI / 2;
            drain.receiveShadow = true;
            blockGroup.add(drain);
            
            // Register for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 1,
                height: 0.1,
                depth: 1,
                type: 'drain'
            });
        }

        // Create a newspaper with simple physics
        function createNewspaper(x, y, z, velocityX, velocityZ) {
            if (papers <= 0) return;
            
            papers--;
            updateUI();
            
            const newspaper = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.1, 0.3),
                new THREE.MeshLambertMaterial({ color: COLORS.NEWSPAPER })
            );
            newspaper.position.set(x, y, z);
            newspaper.castShadow = true;
            scene.add(newspaper);
            
            // Create a raycaster for collision detection
            const raycaster = new THREE.Raycaster();
            
            newspapers.push({
                object: newspaper,
                velocity: new THREE.Vector3(velocityX, 0.2, velocityZ),
                position: newspaper.position.clone(),
                raycaster: raycaster,
                thrown: true,
                delivered: false
            });
        }

        // Set up control listeners
        function setupControls() {
            const keys = {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false,
                w: false,
                a: false,
                s: false,
                d: false,
                ' ': false
            };
            
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                    
                    // Jump when going over a hill
                    if ((e.key === 'ArrowUp' || e.key === 'w') && player.canJump && isOnHill()) {
                        startJump();
                    }
                    
                    // Throw newspaper with space bar
                    if (e.key === ' ' && gameActive && papers > 0) {
                        // Calculate direction - either left or right based on player rotation
                        const throwDirection = new THREE.Vector3();
                        const playerDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(playerObject.quaternion);
                        
                        // Cross product to get perpendicular direction (left or right)
                        // We'll use the current player direction to determine which side to throw
                        const throwSide = Math.sin(playerObject.rotation.y) > 0 ? -1 : 1; // Left or right
                        
                        throwDirection.x = playerDirection.z * throwSide;
                        throwDirection.z = -playerDirection.x * throwSide;

                        createNewspaper(
                            player.position.x + throwDirection.x * 0.5,
                            player.position.y + 1,
                            player.position.z + throwDirection.z * 0.5,
                            throwDirection.x * 0.5,
                            throwDirection.z * 0.5
                        );
                    }
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = false;
                }
            });
            
            // Update player controls
            setInterval(() => {
                if (!gameActive) return;
                
                // Reset lateral velocity only
                player.velocity.x = 0;
                
                // Always move forward automatically
                player.velocity.z = player.speed;
                
                // Apply controls for left and right movement only (reversed as requested)
                if (keys.ArrowLeft || keys.a) {
                    player.velocity.x = player.speed; // Right movement (reversed)
                }
                if (keys.ArrowRight || keys.d) {
                    player.velocity.x = -player.speed; // Left movement (reversed)
                }
                
                // Update player rotation based on movement direction
                const angle = Math.atan2(player.velocity.x, player.velocity.z);
                playerObject.rotation.y = angle;
            }, 16);
            
            // Set up start and restart buttons
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
        }

        // Start jump
        function startJump() {
            if (!isJumping) {
                isJumping = true;
                player.velocity.y = jumpSpeed;
                player.canJump = false;
                
                // Award points for jumping hills
                score += 20;
                updateUI();
            }
        }

        // Check if player is on a hill
        function isOnHill() {
            for (const obstacle of obstacles) {
                if (obstacle.type === 'hill') {
                    const dx = Math.abs(player.position.x - obstacle.position.x);
                    const dz = Math.abs(player.position.z - obstacle.position.z);
                    
                    if (dx < obstacle.width / 2 && dz < obstacle.depth / 2) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the game
        function startGame() {
            gameActive = true;
            startScreen.style.display = 'none';
            score = 0;
            papers = 20;
            lives = 3;
            updateUI();
            clock.start();
        }

        // Restart the game
        function restartGame() {
            // Reset player position
            player.position.set(0, playerHeight, 0);
            playerObject.position.copy(player.position);
            
            // Reset game state
            gameActive = true;
            score = 0;
            papers = 20;
            lives = 3;
            gameTime = 0;
            playerInvincible = false;
            
            // Clear newspapers
            for (const newspaper of newspapers) {
                scene.remove(newspaper.object);
            }
            newspapers = [];
            
            // Update UI
            updateUI();
            gameOverScreen.style.display = 'none';
            clock.start();
        }

        // Game over
        function endGame() {
            gameActive = false;
            gameOverScreen.style.display = 'flex';
            finalScoreElement.textContent = score;
        }

        // Update UI elements
        function updateUI() {
            scoreElement.textContent = score;
            papersElement.textContent = papers;
            livesElement.textContent = lives;
        }

        // Check collisions between player and obstacles
        function checkObstacleCollisions() {
            if (playerInvincible) return false;
            
            for (const obstacle of obstacles) {
                if (obstacle.type === 'hill') continue; // Hills are not obstacles
                
                const dx = Math.abs(player.position.x - obstacle.position.x);
                const dz = Math.abs(player.position.z - obstacle.position.z);
                
                if (dx < (player.width / 2 + obstacle.width / 2) * 0.7 &&
                    dz < (player.depth / 2 + obstacle.depth / 2) * 0.7) {
                    
                    // Collision detected
                    score -= 5;
                    lives--;
                    updateUI();
                    
                    // Make player invincible for a short time
                    playerInvincible = true;
                    playerInvincibleTime = 0;
                    
                    // Check game over
                    if (lives <= 0) {
                        endGame();
                    }
                    
                    return true;
                }
            }
            return false;
        }

        // Check newspaper deliveries
        function checkNewspaperDeliveries() {
            for (const newspaper of newspapers) {
                if (newspaper.delivered) continue;
                
                // Check mailbox deliveries
                for (const mailbox of mailboxes) {
                    const dx = Math.abs(newspaper.position.x - mailbox.position.x);
                    const dz = Math.abs(newspaper.position.z - mailbox.position.z);
                    const dy = Math.abs(newspaper.position.y - 1.2); // Check height relative to mailbox
                    
                    if (dx < (mailbox.width/2 + 0.3) && // Slightly larger detection area
                        dz < (mailbox.length/2 + 0.3) && 
                        dy < 1.5) { // More forgiving height check
                        
                        // Delivered to mailbox
                        newspaper.delivered = true;
                        score += 20;
                        updateUI();
                        break;
                    }
                }
                
                // Check porch deliveries
                for (const porch of porches) {
                    const dx = Math.abs(newspaper.position.x - porch.position.x);
                    const dz = Math.abs(newspaper.position.z - porch.position.z);
                    const dy = newspaper.position.y; // Check height from ground
                    
                    if (dx < (porch.width/2 + 0.5) && // Larger detection area
                        dz < (porch.length/2 + 0.5) && 
                        dy < 1.0) { // More forgiving height check
                        
                        // Delivered to porch
                        newspaper.delivered = true;
                        score += 10;
                        updateUI();
                        break;
                    }
                }
            }
        }

        // Update newspapers with improved collision detection
        function updateNewspapers(delta) {
        for (let i = newspapers.length - 1; i >= 0; i--) {
            const newspaper = newspapers[i];
            
            if (newspaper.thrown && !newspaper.delivered) {
                // Store current position
                const oldPosition = newspaper.position.clone();
                
                // Apply simple gravity
                newspaper.velocity.y -= 0.01;
                
                // Update position
                const newPosition = newspaper.position.clone();
                newPosition.x += newspaper.velocity.x;
                newPosition.y += newspaper.velocity.y;
                newPosition.z += newspaper.velocity.z;
                
                // Cast a ray from current position to next position
                newspaper.raycaster.set(oldPosition, newPosition.clone().sub(oldPosition).normalize());
                
                // Get all intersecting objects along the path
                const intersects = newspaper.raycaster.intersectObjects(scene.children, true);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    // Stop at the intersection point
                    newspaper.position.copy(hit.point);
                    newspaper.thrown = false;
                    
                    // Check what was hit
                    let parent = hit.object;
                    while (parent.parent && !parent.userData.type) {
                        parent = parent.parent;
                    }
                    
                    if (parent.userData.type === 'mailbox') {
                        newspaper.delivered = true;
                        score += 20;
                        updateUI();
                    } else if (parent.userData.type === 'porch') {
                        newspaper.delivered = true;
                        score += 10;
                        updateUI();
                    }
                } else {
                    // No collision, update position
                    newspaper.position.copy(newPosition);
                    
                    // Ground collision
                    if (newspaper.position.y <= 0.05) {
                        newspaper.position.y = 0.05;
                        newspaper.thrown = false;
                    }
                }
                
                // Update visual position
                newspaper.object.position.copy(newspaper.position);
            }
            
            // Remove old undelivered papers
            if (!newspaper.thrown && !newspaper.delivered && gameTime > 30) {
                scene.remove(newspaper.object);
                newspapers.splice(i, 1);
            }
        }
    }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            deltaTime = clock.getDelta();
            
            if (gameActive) {
                gameTime += deltaTime;
                
                // Update player position
                if (!checkObstacleCollisions()) {
                    player.position.x += player.velocity.x;
                    player.position.z += player.velocity.z;
                    
                    // Limit player to road area
                    player.position.x = Math.max(-15, Math.min(15, player.position.x));
                }
                
                // Handle jumping
                if (isJumping) {
                    player.position.y += player.velocity.y;
                    player.velocity.y -= 0.01;
                    
                    if (player.position.y <= playerHeight) {
                        player.position.y = playerHeight;
                        isJumping = false;
                        player.velocity.y = 0;
                        player.canJump = true;
                    }
                }
                
                // Update player object position
                playerObject.position.copy(player.position);
                
                // Update camera position
                camera.position.x = player.position.x * 0.5;
                camera.position.z = player.position.z - 15;
                camera.lookAt(player.position.x, player.position.y, player.position.z + 10);
                
                // Handle player invincibility
                if (playerInvincible) {
                    playerInvincibleTime += deltaTime;
                    playerBlinkTime += deltaTime;
                    
                    // Blink effect
                    if (playerBlinkTime > 0.1) {
                        playerBlinkTime = 0;
                        playerVisible = !playerVisible;
                        playerObject.visible = playerVisible;
                    }
                    
                    // End invincibility after 2 seconds
                    if (playerInvincibleTime > 2) {
                        playerInvincible = false;
                        playerObject.visible = true;
                    }
                }
                
                // Update newspapers
                updateNewspapers(deltaTime);
                checkNewspaperDeliveries();
                
                // End game if out of papers and lives
                if (papers <= 0 && newspapers.length === 0 && lives > 0) {
                    endGame();
                }
            }
            
            renderer.render(scene, camera);
        }

        // Initialize the game when the document is loaded
        init();
    </script>
</body>
</html>