<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paperboy 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: yellow;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 200;
            color: white;
        }
        #start-screen h1 {
            font-size: 48px;
            color: yellow;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #ff0000;
        }
        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 20px;
        }
        #start-button:hover {
            background-color: #cc0000;
        }
        #game-over {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 300;
            color: white;
        }
        #game-over h2 {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 20px;
        }
        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 20px;
        }
        #restart-button:hover {
            background-color: #cc0000;
        }
        @font-face {
            font-family: 'Press Start 2P';
            src: url('https://fonts.gstatic.com/s/pressstart2p/v14/e3t4euO8T-267oIAQAu6jDQyK0nS.woff2') format('woff2');
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-container">
            <div>SCORE: <span id="score">0</span></div>
            <div>PAPERS: <span id="papers">20</span></div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
        <div id="instructions">
            <p>Arrow keys or WASD to move</p>
            <p>Space bar to throw paper</p>
            <p>Deliver to mailboxes (20 pts) or porches (10 pts)</p>
            <p>Avoid obstacles (-5 pts)</p>
            <p>Jump hills in parks for bonus points (+20 pts)</p>
        </div>
        <div id="start-screen">
            <h1>PAPERBOY 3D</h1>
            <p>Deliver newspapers to houses and avoid obstacles!</p>
            <button id="start-button">START GAME</button>
        </div>
        <div id="game-over">
            <h2>GAME OVER</h2>
            <div>FINAL SCORE: <span id="final-score">0</span></div>
            <button id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // Game variables
        let scene, camera, renderer;
        let player, playerObject, playerSpeed = 0.15;
        let gameActive = false;
        let score = 0;
        let papers = 20;
        let lives = 3;
        let gameBlocks = [];
        let obstacles = [];
        let houses = [];
        let newspapers = [];
        let mailboxes = [];
        let porches = [];
        let blockLength = 30;
        let blockWidth = 20;
        let streetWidth = 10;
        let currentBlock = 0;
        let totalBlocks = 20;
        let jumpHeight = 0;
        let isJumping = false;
        let jumpSpeed = 0.2;
        let playerHeight = 1;
        let clock = new THREE.Clock();
        let deltaTime;
        let playerInvincible = false;
        let playerInvincibleTime = 0;
        let playerBlinkTime = 0;
        let playerVisible = true;
        let gameTime = 0;

        // DOM elements
        const scoreElement = document.getElementById('score');
        const papersElement = document.getElementById('papers');
        const livesElement = document.getElementById('lives');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // Colors for the game
        const COLORS = {
            STREET: 0x888888,
            SIDEWALK: 0xcccccc,
            GRASS: 0x33cc33,
            HOUSE_WALL: 0x666666,
            HOUSE_ROOF: 0x333333,
            PORCH: 0xffffff,
            MAILBOX: 0xff0000,
            CAR: 0xff0000,
            PLAYER: 0x0000ff,
            NEWSPAPER: 0xffff00,
            HILL: 0x228822,
            DRAIN: 0x444444
        };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, -15);
            camera.lookAt(0, 0, 10);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            scene.add(directionalLight);

            // Create player
            createPlayer();

            // Generate the game world
            generateWorld();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Set up controls
            setupControls();

            // Start the game loop
            animate();
        }

        // Create the player character
        function createPlayer() {
            playerObject = new THREE.Group();
            
            // Create bicycle
            const bikeFrame = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            bikeFrame.position.y = 0.5;
            playerObject.add(bikeFrame);

            // Wheels
            const wheelGeometry = new THREE.TorusGeometry(0.5, 0.1, 16, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontWheel.position.set(0, 0.5, -0.6);
            frontWheel.rotation.x = Math.PI / 2;
            playerObject.add(frontWheel);
            
            const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backWheel.position.set(0, 0.5, 0.6);
            backWheel.rotation.x = Math.PI / 2;
            playerObject.add(backWheel);

            // Rider
            const riderBody = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.8, 0.4),
                new THREE.MeshLambertMaterial({ color: COLORS.PLAYER })
            );
            riderBody.position.set(0, 1.2, 0);
            playerObject.add(riderBody);

            const riderHead = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                new THREE.MeshLambertMaterial({ color: 0xFFCCAA })
            );
            riderHead.position.set(0, 1.7, 0);
            playerObject.add(riderHead);

            // Newspaper bag
            const newspaperBag = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.4, 0.6),
                new THREE.MeshLambertMaterial({ color: 0xBB5500 })
            );
            newspaperBag.position.set(0, 1.2, 0.5);
            playerObject.add(newspaperBag);

            // Add player to scene
            playerObject.position.set(0, playerHeight, 0);
            playerObject.castShadow = true;
            playerObject.receiveShadow = true;
            scene.add(playerObject);

            // Set player
            player = {
                object: playerObject,
                width: 1,
                height: 2,
                depth: 1.5,
                position: new THREE.Vector3(0, playerHeight, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                speed: playerSpeed,
                canJump: true
            };
        }

        // Generate the game world
        function generateWorld() {
            // Create ground
            for (let i = 0; i < totalBlocks; i++) {
                const isPark = i > 0 && i % 3 === 0;
                createBlock(i, isPark);
            }
        }

        // Create a block of houses or a park
        function createBlock(blockIndex, isPark) {
            const blockZ = blockIndex * (blockLength + streetWidth);
            const block = new THREE.Group();
            block.position.z = blockZ;
            
            if (isPark) {
                createPark(block);
            } else {
                createHousesBlock(block);
            }
            
            // Add cross-street at the end of each block
            if (blockIndex > 0) {
                createCrossStreet(block, -streetWidth/2);
            }
            
            scene.add(block);
            gameBlocks.push(block);
        }
        
        // Create a cross-street
        function createCrossStreet(blockGroup, zOffset) {
            // Street
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth * 3, streetWidth),
                new THREE.MeshLambertMaterial({ color: COLORS.STREET })
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0.06, zOffset);
            street.receiveShadow = true;
            blockGroup.add(street);
            
            // White lines on the street
            const lineWidth = 0.3;
            const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            
            // Center line
            const centerLine = new THREE.Mesh(
                new THREE.PlaneGeometry(lineWidth, streetWidth - 1),
                lineMaterial
            );
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.set(0, 0.07, zOffset);
            centerLine.receiveShadow = true;
            blockGroup.add(centerLine);
            
            // Side lines
            for (let i = -1; i <= 1; i += 2) {
                const sideLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(lineWidth, streetWidth - 1),
                    lineMaterial
                );
                sideLine.rotation.x = -Math.PI / 2;
                sideLine.position.set(blockWidth * 0.5 * i, 0.07, zOffset);
                sideLine.receiveShadow = true;
                blockGroup.add(sideLine);
            }
            
            // Add some street props
            addStreetProps(blockGroup, zOffset);
        }
        
        // Add props to the cross-street
        function addStreetProps(blockGroup, zOffset) {
            // Street lights
            for (let i = -1; i <= 1; i += 2) {
                const lightPole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 4, 8),
                    new THREE.MeshLambertMaterial({ color: 0x333333 })
                );
                lightPole.position.set(blockWidth * 0.7 * i, 2, zOffset);
                lightPole.castShadow = true;
                blockGroup.add(lightPole);
                
                const lightHead = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.3, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0x555555 })
                );
                lightHead.position.set(blockWidth * 0.7 * i, 4, zOffset);
                lightHead.castShadow = true;
                blockGroup.add(lightHead);
                
                // Light cone
                const light = new THREE.PointLight(0xFFFF99, 0.5, 10);
                light.position.set(blockWidth * 0.7 * i, 4, zOffset);
                blockGroup.add(light);
            }
            
            // Add stop signs at intersections
            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    if (Math.random() > 0.5) {
                        createStopSign(
                            blockGroup,
                            blockWidth * 0.5 * i,
                            zOffset + streetWidth * 0.4 * j
                        );
                    }
                }
            }
        }
        
        // Create a stop sign
        function createStopSign(blockGroup, x, z) {
            const signGroup = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                new THREE.MeshLambertMaterial({ color: 0x888888 })
            );
            pole.position.y = 1;
            pole.castShadow = true;
            signGroup.add(pole);
            
            // Sign
            const sign = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 0.05, 8),
                new THREE.MeshLambertMaterial({ color: 0xFF0000 })
            );
            sign.position.y = 2;
            sign.rotation.x = Math.PI / 2;
            sign.castShadow = true;
            signGroup.add(sign);
            
            // Add to block
            signGroup.position.set(x, 0, z);
            blockGroup.add(signGroup);
            
            // Register for collision
            obstacles.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 0.3,
                height: 2,
                depth: 0.3,
                type: 'sign'
            });
        }

        // Create a block with houses
        function createHousesBlock(blockGroup) {
            // Create street
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth + streetWidth * 2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.STREET })
            );
            street.rotation.x = -Math.PI / 2;
            street.position.z = blockLength / 2;
            street.receiveShadow = true;
            blockGroup.add(street);
            
            // Create sidewalks
            const leftSidewalk = new THREE.Mesh(
                new THREE.PlaneGeometry(2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.SIDEWALK })
            );
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-(blockWidth / 2) - 1, 0.05, blockLength / 2);
            leftSidewalk.receiveShadow = true;
            blockGroup.add(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(
                new THREE.PlaneGeometry(2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.SIDEWALK })
            );
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set((blockWidth / 2) + 1, 0.05, blockLength / 2);
            rightSidewalk.receiveShadow = true;
            blockGroup.add(rightSidewalk);
            
            // Create lawns
            const leftLawn = new THREE.Mesh(
                new THREE.PlaneGeometry(8, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.GRASS })
            );
            leftLawn.rotation.x = -Math.PI / 2;
            leftLawn.position.set(-(blockWidth / 2) - 6, 0.05, blockLength / 2);
            leftLawn.receiveShadow = true;
            blockGroup.add(leftLawn);
            
            const rightLawn = new THREE.Mesh(
                new THREE.PlaneGeometry(8, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.GRASS })
            );
            rightLawn.rotation.x = -Math.PI / 2;
            rightLawn.position.set((blockWidth / 2) + 6, 0.05, blockLength / 2);
            rightLawn.receiveShadow = true;
            blockGroup.add(rightLawn);
            
            // Create houses (4 on each side)
            const houseWidth = 6;
            const houseLength = 5;
            const houseSpacing = (blockLength - (houseLength * 4)) / 5;
            
            for (let i = 0; i < 4; i++) {
                const houseZ = houseSpacing + i * (houseLength + houseSpacing);
                
                // Left side house
                createHouse(
                    blockGroup, 
                    -(blockWidth / 2) - 6 + (houseWidth / 2), 
                    houseZ,
                    houseWidth,
                    houseLength,
                    Math.random() > 0.5 // Random side for mailbox
                );
                
                // Right side house
                createHouse(
                    blockGroup, 
                    (blockWidth / 2) + 6 - (houseWidth / 2), 
                    houseZ,
                    houseWidth,
                    houseLength,
                    Math.random() > 0.5 // Random side for mailbox
                );
            }
            
            // Add obstacles
            addObstacles(blockGroup);
        }

        // Create a house
        function createHouse(blockGroup, x, z, width, length, mailboxOnLeft) {
            const houseGroup = new THREE.Group();
            
            // Base/foundation
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(width, 0.5, length),
                new THREE.MeshLambertMaterial({ color: 0x999999 })
            );
            base.position.y = 0.25;
            base.receiveShadow = true;
            houseGroup.add(base);
            
            // Main house structure
            const wallHeight = 3;
            const walls = new THREE.Mesh(
                new THREE.BoxGeometry(width, wallHeight, length),
                new THREE.MeshLambertMaterial({ color: COLORS.HOUSE_WALL })
            );
            walls.position.y = wallHeight / 2 + 0.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            houseGroup.add(walls);
            
            // Roof
            const roofHeight = 2;
            const roofGeometry = new THREE.ConeGeometry(
                width / Math.sqrt(2), 
                roofHeight, 
                4
            );
            const roof = new THREE.Mesh(
                roofGeometry,
                new THREE.MeshLambertMaterial({ color: COLORS.HOUSE_ROOF })
            );
            roof.position.y = wallHeight + 0.5 + roofHeight / 2;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);
            
            // Windows
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x88CCFF });
            
            // Front windows
            const frontWindow1 = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 1),
                windowMaterial
            );
            frontWindow1.position.set(0, wallHeight / 2 + 0.5, length / 2 + 0.01);
            frontWindow1.rotation.y = Math.PI;
            houseGroup.add(frontWindow1);
            
            // Back windows
            const backWindow1 = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 1),
                windowMaterial
            );
            backWindow1.position.set(0, wallHeight / 2 + 0.5, -length / 2 - 0.01);
            houseGroup.add(backWindow1);
            
            // Side windows
            const sideWindow1 = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 1),
                windowMaterial
            );
            sideWindow1.position.set(width / 2 + 0.01, wallHeight / 2 + 0.5, 0);
            sideWindow1.rotation.y = -Math.PI / 2;
            houseGroup.add(sideWindow1);
            
            const sideWindow2 = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 1),
                windowMaterial
            );
            sideWindow2.position.set(-width / 2 - 0.01, wallHeight / 2 + 0.5, 0);
            sideWindow2.rotation.y = Math.PI / 2;
            houseGroup.add(sideWindow2);
            
            // Door
            const door = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 2),
                new THREE.MeshLambertMaterial({ color: 0xAA3333 })
            );
            door.position.set(-1, 1.5, length / 2 + 0.01);
            door.rotation.y = Math.PI;
            houseGroup.add(door);
            
            // Porch
            const porch = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.2, 2),
                new THREE.MeshLambertMaterial({ color: COLORS.PORCH })
            );
            porch.position.set(-1, 0.6, length / 2 + 1);
            porch.receiveShadow = true;
            houseGroup.add(porch);
            
            // Add house to block
            houseGroup.position.set(x, 0, z);
            blockGroup.add(houseGroup);

            // Create mailbox
            const mailboxX = mailboxOnLeft ? x - width / 2 - 1 : x + width / 2 + 1;
            const mailboxZ = z + length / 4;
            createMailbox(blockGroup, mailboxX, mailboxZ);
            
            // Register houses for collision detection
            houses.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: width,
                length: length,
                porch: {
                    position: new THREE.Vector3(x - 1, 0, z + length / 2 + 1 + blockGroup.position.z),
                    width: 3,
                    length: 2
                }
            });
            
            // Add porch to deliverable locations
            porches.push({
                position: new THREE.Vector3(x - 1, 0, z + length / 2 + 1 + blockGroup.position.z),
                width: 3,
                length: 2
            });
        }

        // Create a mailbox with more detail
        function createMailbox(blockGroup, x, z) {
            const mailboxGroup = new THREE.Group();
            
            // Random mailbox style (0, 1, or 2)
            const mailboxStyle = Math.floor(Math.random() * 3);
            let mailboxColor;
            
            switch(mailboxStyle) {
                case 0: // Classic red
                    mailboxColor = 0xCC0000;
                    break;
                case 1: // Black
                    mailboxColor = 0x222222;
                    break;
                case 2: // Blue
                    mailboxColor = 0x0033AA;
                    break;
            }
            
            // Post
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            
            if (mailboxStyle === 0) { // Wooden post
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1.2, 0.2),
                    postMaterial
                );
                post.position.y = 0.6;
                post.castShadow = true;
                mailboxGroup.add(post);
            } else if (mailboxStyle === 1) { // Metal pole
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                post.position.y = 0.6;
                post.castShadow = true;
                mailboxGroup.add(post);
                
                // Base
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.1, 8),
                    new THREE.MeshLambertMaterial({ color: 0x666666 })
                );
                base.position.y = 0.05;
                base.castShadow = true;
                mailboxGroup.add(base);
            } else { // Stone base
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.9, 0.3),
                    new THREE.MeshLambertMaterial({ color: 0x999999 })
                );
                post.position.y = 0.45;
                post.castShadow = true;
                mailboxGroup.add(post);
                
                // Stone texture
                for (let i = 0; i < 5; i++) {
                    const stone = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05 + Math.random() * 0.1, 0.05 + Math.random() * 0.1, 0.05),
                        new THREE.MeshLambertMaterial({ color: 0x888888 })
                    );
                    stone.position.set(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.8,
                        0.17
                    );
                    post.add(stone);
                }
            }
            
            // Box style based on mailbox type
            let boxGeometry;
            if (mailboxStyle === 0) { // Classic curved top
                boxGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.4);
                
                // Curved top
                const topCurve = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 0.8, 16, 1, false, 0, Math.PI),
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                topCurve.rotation.z = Math.PI / 2;
                topCurve.position.set(0, 0.25, 0);
                
                const box = new THREE.Mesh(
                    boxGeometry,
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                
                const boxWrapper = new THREE.Group();
                boxWrapper.add(box);
                boxWrapper.add(topCurve);
                boxWrapper.position.y = 1.2;
                boxWrapper.castShadow = true;
                mailboxGroup.add(boxWrapper);
                
                // Flag
                const flag = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.3, 0.2),
                    new THREE.MeshLambertMaterial({ color: 0xFF0000 })
                );
                flag.position.set(0.425, 1.3, 0);
                flag.castShadow = true;
                mailboxGroup.add(flag);
                
            } else if (mailboxStyle === 1) { // Modern box with slot
                boxGeometry = new THREE.BoxGeometry(0.8, 0.7, 0.4);
                
                const box = new THREE.Mesh(
                    boxGeometry,
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                box.position.y = 1.2;
                box.castShadow = true;
                mailboxGroup.add(box);
                
                // Mail slot
                const slot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.08, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0x000000 })
                );
                slot.position.set(0, 1.3, 0.225);
                mailboxGroup.add(slot);
                
            } else { // Decorative box
                boxGeometry = new THREE.BoxGeometry(0.9, 0.6, 0.5);
                
                const box = new THREE.Mesh(
                    boxGeometry,
                    new THREE.MeshLambertMaterial({ color: mailboxColor })
                );
                box.position.y = 1.1;
                box.castShadow = true;
                mailboxGroup.add(box);
                
                // Decorative trim
                const trim = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.05, 0.6),
                    new THREE.MeshLambertMaterial({ color: 0xDDDDDD })
                );
                trim.position.y = 1.4;
                mailboxGroup.add(trim);
                
                // House number
                const numberPlate = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 0.15),
                    new THREE.MeshLambertMaterial({ color: 0xEEEEEE })
                );
                numberPlate.position.set(0, 1.25, 0.26);
                mailboxGroup.add(numberPlate);
            }
            
            // Add to block
            mailboxGroup.position.set(x, 0, z);
            blockGroup.add(mailboxGroup);
            
            // Register for collision
            mailboxes.push({
                position: new THREE.Vector3(x, 0, z + blockGroup.position.z),
                width: 1,
                length: 0.5
            });
        }

        // Create a park with more detailed elements
        function createPark(blockGroup) {
            // Create ground with texture variation
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth + streetWidth * 2, blockLength),
                new THREE.MeshLambertMaterial({ color: COLORS.GRASS })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = blockLength / 2;
            ground.receiveShadow = true;
            blockGroup.add(ground);
            
            // Add texture variation with patches of different grass
            for (let i = 0; i < 20; i++) {
                const patchSize = 1.5 + Math.random() * 3;
                const patchX = (Math.random() - 0.5) * (blockWidth + streetWidth * 2 - patchSize);
                const patchZ = Math.random() * blockLength;
                
                const grassPatch = new THREE.Mesh(
                    new THREE.CircleGeometry(patchSize / 2, 8),
                    new THREE.MeshLambertMaterial({ 
                        color: Math.random() > 0.5 ? 0x44AA44 : 0x55BB55,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                grassPatch.rotation.x = -Math.PI / 2;
                grassPatch.position.set(patchX, 0.01, patchZ);
                blockGroup.add(grassPatch);
            }
            
            // Create street/path through the park
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(blockWidth, blockLength),
                new THREE.MeshLambertMaterial({ color: 0xbbbbbb }) // Lighter color for park path
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0.05, blockLength / 2);
            street.receiveShadow = true;
            blockGroup.add(street);
            
            // Add path texture - crossing lines
            for (let i = 0; i < blockLength / 2; i++) {
                const pathLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(blockWidth, 0.1),
                    new THREE.MeshLambertMaterial({ color: 0x999999 })
                );
                pathLine.rotation.x = -Math.PI / 2;
                pathLine.position.set(0, 0.06, i * 2);
                blockGroup.add(pathLine);
            }
            
            // Create hills - more varied
            for (let i = 0; i < 3; i++) {
                const hillZ = blockLength / 4 + i * (blockLength / 3);
                const offsetX = (i % 2 === 0) ? 2 : -2; // Alternate sides
                createHill(blockGroup, offsetX, hillZ);
            }
            
            // Add some trees - more variety
            for (let i = 0; i < 12; i++) {
                const treeX = (Math.random() - 0.5) * (blockWidth + streetWidth * 2 - 4);
                const treeZ = Math.random() * blockLength;
                
                // Don't place trees on the path
                if (Math.abs(treeX) > 5) {
                    createTree(blockGroup, treeX, treeZ, Math.floor(Math.random() * 3));
                }
            }
            
            // Add park benches
            for (let i = 0; i < 3; i++) {
                const benchSide = i % 2 === 0 ? 1 : -1;
                const benchX = benchSide * (blockWidth / 2 - 2);
                const benchZ = blockLength / 4 + i * (blockLength / 3);
                createBench(blockGroup, benchX, benchZ, benchSide);
            }
            
            // Add some flowers
            for (let i = 0; i < 20; i++) {
                const flowerX = (Math.random() - 0.5) * (blockWidth + streetWidth * 2 - 2);
                const flowerZ = Math.random() * blockLength;
                
                // Don't place flowers on the path
                if (Math.abs(flowerX) > 5) {
                    createFlower(blockGroup, flowerX, flowerZ);
                }
            }
            
            // Add a small pond
            if (Math.random() > 0.5) {
                const pondX = (Math.random() - 0.5) * (blockWidth - 10);
                const pondZ = blockLength / 2 + (Math.random() - 0.5) * (blockLength / 2 - 5);
                createPond(blockGroup, pondX, pondZ);
            }
        }